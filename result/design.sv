module timer_core #(
  parameter int N = 1
) (
  input clk_i,
  input rst_ni,

  input        active,
  input [11:0] prescaler,
  input [ 7:0] step,

  output logic        tick,
  output logic [63:0] mtime_d,
  input        [63:0] mtime,
  input        [63:0] mtimecmp [N],

  output logic [N-1:0] intr
);

  logic [11:0] tick_count;

  always_ff @(posedge clk_i or negedge rst_ni) begin : generate_tick
    if (!rst_ni) begin
      tick_count <= 12'h0;
    end else if (!active) begin
      tick_count <= 12'h0;
    end else if (tick_count == prescaler) begin
      tick_count <= 12'h0;
    end else begin
      tick_count <= tick_count + 1'b1;
    end
  end

  assign tick = active & (tick_count >= prescaler);

  assign mtime_d = mtime + 64'(step);

  // interrupt is generated if mtime is greater than or equal to mtimecmp
  for (genvar t = 0 ; t < N ; t++) begin : gen_intr
    assign intr[t] = active & (mtime >= mtimecmp[t]);
  end
  
  
  // Assertion to check if tick_count resets to 0 on reset
  property p_reset_tick_count;
  @(posedge clk_i) (!rst_ni) |=> (tick_count == 12'h0);
    endproperty
  assert property (p_reset_tick_count);


  // Assertion to check if tick_count resets to 0 when 'active' is deasserted
    
  property p_deactivate_tick_count;
     @(posedge clk_i) (!active) |=> (tick_count == 12'h0);
  endproperty
  assert property (p_deactivate_tick_count);


    // Assertion to check if tick_count resets when it equals prescaler  (Extra Assertion Generated by LLM)
  property p_tick_count_reset_on_prescaler;
    @(posedge clk_i) (tick_count == prescaler) |=> (tick_count == 12'h0);
  endproperty
  assert property (p_tick_count_reset_on_prescaler);

 // Assertion for tick_count increment
  property tick_count_increment;
    @(posedge clk_i)
    (rst_ni && active && (tick_count < prescaler))  |=> (tick_count == $past(tick_count) + 1);
  endproperty
  assert property (tick_count_increment);
        

  // Assertion for tick_count reset on reset deassertion
  property tick_count_reset_on_reset_deassert;
    @(posedge clk_i)
    (!$past(rst_ni, 1) && rst_ni) -> (tick_count == 0);
  endproperty
  assert property (tick_count_reset_on_reset_deassert);


  // Assertion to check if tick is generated correctly
  property p_tick_generation;
    @(posedge clk_i) (tick == (active && (tick_count >= prescaler)));
  endproperty
  assert property (p_tick_generation);

  // Assertion to check mtime increment
  property p_mtime_increment;
    @(posedge clk_i) (mtime_d == mtime + step);
  endproperty
  assert property (p_mtime_increment);

  // Assertions for each timer interrupt
  generate
    for (genvar t = 0; t < N; t++) begin : gen_intr_assertions
      property p_intr_generation;
        @(posedge clk_i) (intr[t] == (active && (mtime >= mtimecmp[t])));
      endproperty
      assert property (p_intr_generation);
    end
  endgenerate// Code your design here
endmodule : timer_core
